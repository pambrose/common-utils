import org.jetbrains.kotlin.gradle.dsl.JvmTarget
import org.jetbrains.kotlin.gradle.tasks.KotlinJvmCompile

plugins {
    id 'java-library'
    id 'maven-publish'

    //id 'org.jetbrains.kotlinx.kover' version '0.5.0'
    alias(libs.plugins.coveralls) apply false
    alias(libs.plugins.kotlin.jvm) apply false
    alias(libs.plugins.kotlin.serialization) apply false
    alias(libs.plugins.kotlinter) apply false
    alias(libs.plugins.versions) apply false
}

allprojects {
    group = 'com.github.pambrose.common-utils'
    version = '2.3.11'

    apply plugin: 'java-library'
    apply plugin: 'maven-publish'
    apply plugin: libs.plugins.coveralls.get().pluginId
    apply plugin: libs.plugins.kotlinter.get().pluginId
    apply plugin: libs.plugins.kotlin.jvm.get().pluginId
    apply plugin: libs.plugins.versions.get().pluginId
    apply plugin: libs.plugins.kotlin.serialization.get().pluginId

    repositories {
        google()
        mavenCentral()
    }

    //cobertura.coverageSourceDirs = sourceSets.main.groovy.srcDirs

    publishing {
        publications {
            mavenJava(MavenPublication) {
                from components.java
                versionMapping {
                    usage('java-api') {
                        fromResolutionOf('runtimeClasspath')
                    }
                    usage('java-runtime') {
                        fromResolutionResult()
                    }
                }
            }
        }
    }
}

subprojects {

    dependencies {
        // This is required for the ExperimentalCoroutinesApi arg below
        implementation libs.kotlinx.coroutines

        implementation libs.logging
        implementation libs.logback

        testImplementation libs.kluent
        testImplementation libs.kotlin.test

        testRuntimeOnly libs.junit.platform
    }

    // This is to fix a bizarre gradle error
    project.getTasks().getByName("jar").setProperty("duplicatesStrategy", DuplicatesStrategy.INCLUDE)

    tasks.register('sourcesJar', Jar) {
        dependsOn classes
        from sourceSets.main.allSource
        archiveClassifier = 'sources'
    }

    tasks.register('javadocJar', Jar) {
        dependsOn javadoc
        from javadoc.destinationDir
        archiveClassifier = 'javadoc'
    }

    artifacts {
        archives sourcesJar
        //archives javadocJar
    }

    java {
        withSourcesJar()
    }

//    task sourcesJar(type: Jar, dependsOn: classes) {
//        from sourceSets.main.allJava
//        archiveClassifier.set("sources")
//    }
//
//    task javadocJar(type: Jar, dependsOn: javadoc) {
//        archiveClassifier.set("javadoc")
//        from javadoc.destinationDir
//    }

    kotlin {
        jvmToolchain(11)
    }

    tasks.withType(KotlinJvmCompile).configureEach {
        compilerOptions {
            jvmTarget.set(JvmTarget.JVM_11)
            freeCompilerArgs.addAll([
                "-Xbackend-threads=8",
                "-opt-in=kotlin.contracts.ExperimentalContracts",
                "-opt-in=kotlinx.coroutines.ExperimentalCoroutinesApi",
                "-opt-in=kotlin.time.ExperimentalTime",
                "-opt-in=kotlin.concurrent.atomics.ExperimentalAtomicApi"
            ])
        }
    }

    test {
        useJUnitPlatform()

        testLogging {
            events "passed", "skipped", "failed", "standardOut", "standardError"
            exceptionFormat = "full"
            showStandardStreams = true
        }
    }

    kotlinter {
        reporters = ['checkstyle', 'plain']
    }

//    jacocoTestReport {
//        reports {
//            xml.enabled = true // coveralls plugin depends on xml format report
//            html.enabled = true
//        }
//    }
//
//    coveralls {
//        jacocoReportPath 'build/reports/jacoco/jacocoTestReport/jacocoTestReport.xml'
//    }
}
